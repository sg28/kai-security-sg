import { FilterOptions, Vulnerability } from '../types/vulnerability';

const GITHUB_URL = 'https://raw.githubusercontent.com/chanduusc/Ui-Demo-Data/main/ui_demo.json';
const SUPABASE_URL = 'https://nnshnjulohvdrzqsznfz.supabase.co/storage/v1/object/public/vulnerabilities/ui_demo.json';

export async function loadVulnerabilityData(): Promise<Vulnerability[]> {
  try {
    const githubResponse = await fetch(GITHUB_URL);
    if (githubResponse.ok) {
      const githubData = await githubResponse.json();
      console.log("githubData ", githubData)
      if (githubData.groups) {
        return extractVulnerabilities(githubData);
      }
    }
  } catch (githubError) {
    console.warn('GitHub fetch failed, trying Supabase:', githubError);
  }

  // Try Supabase as fallback
  try {
    const supabaseResponse = await fetch(SUPABASE_URL);
    if (supabaseResponse.ok) {
      const supabaseData = await supabaseResponse.json();
      console.log("supabaseData ", supabaseData)
      if (supabaseData.groups) {
        return extractVulnerabilities(supabaseData);
      }
    }
  } catch (supabaseError) {
    console.error('Supabase fetch also failed:', supabaseError);
  }

  return [];
}

function extractVulnerabilities(raw: any): Vulnerability[] {
  const data = raw as {
    groups: Record<string, {
      repos: Record<string, {
        images: Record<string, {
          vulnerabilities: Vulnerability[];
          createTime?: string;
        }>;
      }>;
    }>;
  };

  const allVulns: Vulnerability[] = [];

  for (const group of Object.values(data.groups || {})) {
    for (const repo of Object.values(group.repos || {})) {
      for (const image of Object.values(repo.images || {})) {
        if (Array.isArray(image.vulnerabilities)) {
          allVulns.push(...image.vulnerabilities);
        }
      }
    }
  }

  return allVulns;
}

export function filterVulnerabilities(
  data: Vulnerability[],
  filters: FilterOptions
): Vulnerability[] {
  return data.filter(vuln => {
    if (filters.severity && !filters.severity.includes(vuln.severity)) return false;
    if (filters.kaiStatus && !filters.kaiStatus.includes(vuln.kaiStatus)) return false;
    if (filters.packageName && !vuln.packageName.includes(filters.packageName)) return false;
    if (filters.minRiskScore && vuln.riskScore < filters.minRiskScore) return false;
    return true;
  });
}
